export class Compiler extends Obj {
    init(templateName: any, throwOnUndefined: any): void;
    templateName: any;
    codebuf: any[];
    lastId: number;
    buffer: any;
    bufferStack: any[];
    _scopeClosers: any;
    inBlock: boolean;
    throwOnUndefined: any;
    fail(msg: any, lineno: any, colno: any): void;
    _pushBuffer(): string;
    _popBuffer(): void;
    _emit(code: any): void;
    _emitLine(code: any): void;
    _emitLines(...lines: any[]): void;
    _emitFuncBegin(node: any, name: any): void;
    _emitFuncEnd(noReturn: any): void;
    _addScopeLevel(): void;
    _closeScopeLevels(): void;
    _withScopedSyntax(func: any): void;
    _makeCallback(res: any): string;
    _tmpid(): string;
    _templateName(): string;
    _compileChildren(node: any, frame: any): void;
    _compileAggregate(node: any, frame: any, startChar: any, endChar: any): void;
    _compileExpression(node: any, frame: any): void;
    assertType(node: any, ...types: any[]): void;
    compileCallExtension(node: any, frame: any, async: any): void;
    compileCallExtensionAsync(node: any, frame: any): void;
    compileNodeList(node: any, frame: any): void;
    compileLiteral(node: any): void;
    compileSymbol(node: any, frame: any): void;
    compileGroup(node: any, frame: any): void;
    compileArray(node: any, frame: any): void;
    compileDict(node: any, frame: any): void;
    compilePair(node: any, frame: any): void;
    compileInlineIf(node: any, frame: any): void;
    compileIn(node: any, frame: any): void;
    compileIs(node: any, frame: any): void;
    _binOpEmitter(node: any, frame: any, str: any): void;
    compileOr(node: any, frame: any): void;
    compileAnd(node: any, frame: any): void;
    compileAdd(node: any, frame: any): void;
    compileConcat(node: any, frame: any): void;
    compileSub(node: any, frame: any): void;
    compileMul(node: any, frame: any): void;
    compileDiv(node: any, frame: any): void;
    compileMod(node: any, frame: any): void;
    compileNot(node: any, frame: any): void;
    compileFloorDiv(node: any, frame: any): void;
    compilePow(node: any, frame: any): void;
    compileNeg(node: any, frame: any): void;
    compilePos(node: any, frame: any): void;
    compileCompare(node: any, frame: any): void;
    compileLookupVal(node: any, frame: any): void;
    _getNodeName(node: any): any;
    compileFunCall(node: any, frame: any): void;
    compileFilter(node: any, frame: any): void;
    compileFilterAsync(node: any, frame: any): void;
    compileKeywordArgs(node: any, frame: any): void;
    compileSet(node: any, frame: any): void;
    compileSwitch(node: any, frame: any): void;
    compileIf(node: any, frame: any, async: any): void;
    compileIfAsync(node: any, frame: any): void;
    _emitLoopBindings(node: any, arr: any, i: any, len: any): void;
    compileFor(node: any, frame: any): void;
    _compileAsyncLoop(node: any, frame: any, parallel: any): void;
    compileAsyncEach(node: any, frame: any): void;
    compileAsyncAll(node: any, frame: any): void;
    _compileMacro(node: any, frame: any): string;
    compileMacro(node: any, frame: any): void;
    compileCaller(node: any, frame: any): void;
    _compileGetTemplate(node: any, frame: any, eagerCompile: any, ignoreMissing: any): string;
    compileImport(node: any, frame: any): void;
    compileFromImport(node: any, frame: any): void;
    compileBlock(node: any): void;
    compileSuper(node: any, frame: any): void;
    compileExtends(node: any, frame: any): void;
    compileInclude(node: any, frame: any): void;
    compileTemplateData(node: any, frame: any): void;
    compileCapture(node: any, frame: any): void;
    compileOutput(node: any, frame: any): void;
    compileRoot(node: any, frame: any): void;
    compile(node: any, frame: any): void;
    getCode(): string;
}
import { Obj } from "./object";
export declare function compile(src: any, asyncFilters: any, extensions: any, name: any, opts?: {}): string;
//# sourceMappingURL=compiler.d.ts.map